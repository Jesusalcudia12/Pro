import telebot
from telebot import types
import netlas, requests, os, sqlite3, subprocess, json, glob, time, logging
from fpdf import FPDF
from datetime import datetime
from urllib.parse import quote, urlparse

# ==========================================
# CONFIGURACI√ìN DE IDENTIDAD Y SEGURIDAD
# ==========================================
TELEGRAM_TOKEN = "8583960709:AAGMxsIwVzlVUu-YvSn6Rfxn3-2Vfe-T3WU"
TELEGRAM_CHAT_ID = 6280594821 
NETLAS_API_KEY = "MheJyCwplJnLO8CU1ZOC7A7OkJFTYvnk"
MI_BILLETERA_USDT = "TWzf9VJmr2mhq5H8Xa3bLhbb8dwmWdG9B7I"
PRECIO_BASE = "350.00 USDT"

# Optimizaci√≥n de hilos para alta concurrencia
bot = telebot.TeleBot(TELEGRAM_TOKEN, threaded=True, num_threads=50)
n_api = netlas.Netlas(api_key=NETLAS_API_KEY)

# ==========================================
# MOTOR DE BASE DE DATOS (Zenith DB Advanced)
# ==========================================
class DatabaseManager:
    def __init__(self, db_name='zenith_titan.db'):
        self.conn = sqlite3.connect(db_name, check_same_thread=False)
        self.cursor = self.conn.cursor()
        self.setup()

    def setup(self):
        self.cursor.execute('''CREATE TABLE IF NOT EXISTS objetivos 
            (id INTEGER PRIMARY KEY AUTOINCREMENT, target TEXT, tipo TEXT, fecha TEXT, monto TEXT)''')
        self.cursor.execute('''CREATE TABLE IF NOT EXISTS logs_auditoria 
            (id INTEGER PRIMARY KEY AUTOINCREMENT, usuario_id TEXT, comando TEXT, ts TEXT)''')
        self.conn.commit()

    def registrar_op(self, target, tipo):
        fecha = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        self.cursor.execute("INSERT INTO objetivos (target, tipo, fecha, monto) VALUES (?, ?, ?, ?)", 
                           (target, tipo, fecha, PRECIO_BASE))
        self.conn.commit()

db = DatabaseManager()

# ==========================================
# MOTOR DE REPORTES PDF (Zenith Pro Graphics)
# ==========================================
class ZenithReport(FPDF):
    def header(self):
        self.set_fill_color(15, 15, 15)
        self.rect(0, 0, 210, 45, 'F')
        self.set_font('Arial', 'B', 28)
        self.set_text_color(255, 255, 255)
        self.cell(0, 25, 'ZENITH TITAN SYSTEMS', 0, 1, 'C')
        self.set_font('Arial', 'I', 11)
        self.cell(0, 5, 'Strategic Cyber-Intelligence & Forensic Division', 0, 1, 'C')
        self.ln(35)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.set_text_color(120, 120, 120)
        self.cell(0, 10, f'Report generated by Zenith Core v63.0 | Security Audit ID: {os.urandom(4).hex().upper()}', 0, 0, 'C')

def generar_pdf_auditoria(target, data_dict):
    pdf = ZenithReport()
    pdf.add_page()
    pdf.set_font("Courier", 'B', 16)
    pdf.cell(0, 10, f"MASTER REPORT: {target.upper()}", ln=True)
    pdf.ln(5)
    
    for seccion, contenido in data_dict.items():
        pdf.set_font("Courier", 'B', 12)
        pdf.set_fill_color(30, 30, 30)
        pdf.set_text_color(255, 255, 255)
        pdf.cell(0, 8, seccion, ln=True, fill=True)
        pdf.set_font("Courier", size=9)
        pdf.set_text_color(0, 0, 0)
        pdf.multi_cell(0, 5, txt=str(contenido))
        pdf.ln(6)
        
    path = f"ZENITH_AUDIT_{target.replace('.', '_')}.pdf"
    pdf.output(path)
    return path

def generar_factura_pago(target):
    pdf = ZenithReport()
    pdf.add_page()
    pdf.set_font("Arial", 'B', 20)
    pdf.cell(0, 20, "INVOICE / ORDEN DE PAGO", ln=True, align='C')
    pdf.ln(10)
    pdf.set_font("Arial", size=12)
    pdf.cell(0, 10, f"Concepto: Auditoria de Seguridad y Pentesting - {target}", ln=True)
    pdf.cell(0, 10, f"Fecha: {datetime.now().strftime('%Y-%m-%d')}", ln=True)
    pdf.cell(0, 10, f"Monto a Pagar: {PRECIO_BASE}", ln=True)
    pdf.ln(10)
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, "Billetera USDT (Network TRC20):", ln=True)
    pdf.set_font("Courier", size=10)
    pdf.cell(0, 10, MI_BILLETERA_USDT, ln=True)
    path = f"INVOICE_{target.replace('.', '_')}.pdf"
    pdf.output(path)
    return path

# ==========================================
# M√ìDULOS DE RECONOCIMIENTO Y CAZA
# ==========================================
def scan_critical_files(url):
    files = [
        ".env", ".git/config", "wp-config.php", "config.php", 
        "database.sql", ".htaccess", "backup.zip", "settings.json",
        ".aws/credentials", ".ssh/id_rsa", "docker-compose.yml", "api/.env"
    ]
    found = []
    base = url if url.startswith("http") else f"https://{url}"
    for f in files:
        try:
            r = requests.head(f"{base.rstrip('/')}/{f}", timeout=4, allow_redirects=False)
            if r.status_code == 200:
                found.append(f"üî¥ [EXPUESTO] {base}/{f}")
        except: continue
    return found

def buscar_en_combos_global(target):
    matches = []
    files = glob.glob("combos/*.txt")
    for txt in files:
        try:
            with open(txt, 'r', encoding='utf-8', errors='ignore') as f:
                for line in f:
                    if target.lower() in line.lower():
                        matches.append(line.strip())
                    if len(matches) >= 40: break
        except: continue
    return matches

# ==========================================
# MANEJADORES DE COMANDOS (BOT)
# ==========================================
@bot.message_handler(commands=['start'])
def welcome(message):
    if message.chat.id != TELEGRAM_CHAT_ID: return
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    markup.add('/scan_url', '/find_bugs', '/upload_combo', '/exploit', '/port_scan', '/status')
    bot.send_message(message.chat.id, "üíé **ZENITH TITAN OMEGA v63.0**\nN√∫cleo especialista en Bug Bounty y OSINT cargado.", parse_mode="Markdown", reply_markup=markup)

@bot.message_handler(commands=['upload_combo'])
def upload_info(message):
    bot.send_message(message.chat.id, "üì© **ALIMENTACI√ìN:** Env√≠ame archivos `.txt` para la carpeta `combos/`.")

@bot.message_handler(content_types=['document'])
def handle_incoming_files(message):
    if message.document.file_name.endswith('.txt'):
        file_info = bot.get_file(message.document.file_id)
        downloaded = bot.download_file(file_info.file_path)
        if not os.path.exists("combos"): os.makedirs("combos")
        path = f"combos/{message.document.file_name}"
        with open(path, 'wb') as f: f.write(downloaded)
        bot.reply_to(message, f"‚úÖ **SISTEMA ALIMENTADO:** `{message.document.file_name}`.")

@bot.message_handler(commands=['find_bugs'])
def hunter_mode(message):
    msg = bot.send_message(message.chat.id, "üéØ **MODO HUNTER:** Ingrese objetivo (Dominio/IP):")
    bot.register_next_step_handler(msg, process_hunter)

def process_hunter(message):
    target = message.text.strip().lower()
    bot.send_message(message.chat.id, "üöÄ **INICIANDO AUDITOR√çA FASE 1: RECON...**")
    
    # 1. Mapeo de Subdominios
    try:
        res = n_api.query(query=f"domain:*.{target}", datatype="domain")
        subs = [item['data']['domain'] for item in res['items'][:20]]
        sub_text = "\n".join([f"‚Ä¢ {s}" for s in subs]) if subs else "Sin subdominios detectados."
    except: sub_text = "Error en Netlas API."

    # 2. Archivos Cr√≠ticos
    bot.send_message(message.chat.id, "üìÇ **FASE 2: ESCANEANDO SECRETS...**")
    leaks = scan_critical_files(target)
    leak_text = "\n".join(leaks) if leaks else "No se detectaron archivos sensibles expuestos."

    # 3. Escaneo Nmap
    bot.send_message(message.chat.id, "‚ö° **FASE 3: ESCANEO VULN (NMAP)...**")
    try:
        nmap_out = subprocess.check_output(["nmap", "-sV", "-Pn", "-T4", "--script=vuln", target], timeout=360, text=True)
    except: nmap_out = "Escaneo detenido o bloqueado."

    # Consolidaci√≥n de Reporte y Factura
    audit_data = {
        "I. RECONOCIMIENTO DE SUBDOMINIOS": sub_text,
        "II. ARCHIVOS CRITICOS EXPUESTOS": leak_text,
        "III. ANALISIS TECNICO DE SERVICIOS": nmap_out
    }
    
    pdf_audit = generar_pdf_auditoria(target, audit_data)
    pdf_invoice = generar_factura_pago(target)
    
    with open(pdf_audit, "rb") as f1, open(pdf_invoice, "rb") as f2:
        bot.send_document(message.chat.id, f1, caption=f"üèÜ **INFORME FINAL:** {target}")
        bot.send_document(message.chat.id, f2, caption=f"üíµ **ORDEN DE COBRO:** {target}")
    
    os.remove(pdf_audit)
    os.remove(pdf_invoice)
    db.registrar_op(target, "FULL_HUNTER_SCAN")

@bot.message_handler(commands=['scan_url'])
def scan_creds(message):
    msg = bot.send_message(message.chat.id, "üîç **BUSCADOR DE LOGS:** Ingrese dominio:")
    bot.register_next_step_handler(msg, process_creds)

def process_creds(message):
    target = message.text.strip().lower()
    matches = buscar_en_combos_global(target)
    res = "\n".join([f"‚Ä¢ `{m}`" for m in matches]) if matches else "‚ùå Sin credenciales filtradas."
    bot.send_message(message.chat.id, f"üîë **CREDENCIALES ENCONTRADAS:**\n\n{res}", parse_mode="Markdown")
    db.registrar_op(target, "CREDENTIAL_EXTRACT")

@bot.message_handler(commands=['status'])
def status_check(message):
    st = f"üìä **ESTADO:**\n‚Ä¢ Versi√≥n: 63.0\n‚Ä¢ Hilos: 50\n‚Ä¢ Combos: {len(glob.glob('combos/*.txt'))} archivos."
    bot.send_message(message.chat.id, st, parse_mode="Markdown")

if __name__ == "__main__":
    if not os.path.exists("combos"): os.makedirs("combos")
    bot.infinity_polling(skip_pending=True)
